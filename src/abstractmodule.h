/*
 * Copyright (C) 2016-2019 Matthias Klumpp <matthias@tenstral.net>
 *
 * Licensed under the GNU General Public License Version 3
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef ABSTRACTMODULE_H
#define ABSTRACTMODULE_H

#include <QObject>
#include <QList>
#include <QByteArray>
#include <QAction>
#include <QPixmap>

#include "modulemanager.h"

/**
 * @brief The ModuleState enum
 *
 * Describes the state a module can be in. The state is usually displayed
 * to the user via a module indicator widget.
 */
enum class ModuleState {
    UNKNOWN,
    PREPARING,
    READY,
    RUNNING,
    ERROR
};

class AbstractModule : public QObject
{
    Q_OBJECT
public:
    explicit AbstractModule(QObject *parent = nullptr);

    virtual ModuleState state() const;

    /**
     * @brief Name of this module used internally as unique identifier
     */
    virtual QString id() const;

    /**
     * @brief Name of this module displayed to the user
     */
    virtual QString displayName() const;

    /**
     * @brief Description of this module
     */
    virtual QString description() const;

    /**
     * @brief Icon of this module
     */
    virtual QPixmap pixmap() const;

    /**
     * @brief Initialize the module
     *
     * Initialize this module. This method is called once after construction.
     * @return true if success
     */
    virtual bool initialize(ModuleManager *manager) = 0;

    /**
     * @brief Prepare for an experiment run
     *
     * Prepare this module to run. This method is called once
     * prior to every experiment run.
     * @return true if success
     */
    virtual bool prepare(const QString& storageRootDir, const QString& subjectId) = 0;

    /**
     * @brief Execute tasks once per processing loop
     *
     * Run one iteration for this module. This function is called in a loop,
     * so make sure it never blocks.
     * @return true if no error
     */
    virtual bool runCycle();

    /**
     * @brief Execute this module's threads.
     * This method is run once when the experiment is started.
     * @return true if successful.
     */
    virtual bool runThreads();

    /**
     * @brief Stop running an experiment.
     * Stop execution of an experiment. This method is called after
     * prepare() was run.
     */
    virtual void stop() = 0;

    /**
     * @brief Finalize this module.
     * This method is called before the module itself is destroyed.
     */
    virtual void finalize();

    /**
     * @brief Show the display widgets of this module
     */
    virtual void showDisplayUi();

    /**
     * @brief Show the configuration UI of this module
     */
    virtual void showSettingsUi();

    /**
     * @brief Hide all display widgets of this module
     */
    virtual void hideDisplayUi();

    /**
     * @brief Hide the configuration UI of this module
     */
    virtual void hideSettingsUi();

    /**
     * @brief Get actions to add to the module's submenu
     * @return
     */
    virtual QList<QAction*> actions();

    /**
     * @brief Serialize the settings of this module to a byte array.
     */
    virtual QByteArray serializeSettings();

    /**
     * @brief Load settings from previously stored data.
     * @return true if successful.
     */
    virtual bool loadSettings(const QByteArray& data);

    /**
     * @brief Return last error
     * @return The last error message generated by this module
     */
    QString lastError() const;

    /**
     * @brief Returns true if only one instance of this module can exist.
     * @return True if singleton.
     */
    virtual bool singleton() const;

    /**
     * @brief Check if the selected module can be removed.
     * This function is called by the module manager prior to removal of a module on
     * each active module. If False is returned, the module is prevented from being removed.
     * @return True if module can be removed, fals if removal should be prevented.
     */
    virtual bool canRemove(AbstractModule *mod);

signals:
    void actionsUpdated();
    void stateChanged(ModuleState state);
    void errorMessage(const QString& message);
    void statusMessage(const QString& message);

protected:
    void setState(ModuleState state);
    void setLastError(const QString& message);
    void setStatusMessage(const QString& message);

    QString m_storageDir;

private:
    ModuleState m_state;
    QString m_lastError;
};

#endif // ABSTRACTMODULE_H
